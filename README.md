## Game Preview
```
Level 1
```
<a href="https://drive.google.com/uc?export=view&id=1KalOjkbgnXov-c6RB6gApp21I585alDD"><img src="https://drive.google.com/uc?export=view&id=1KalOjkbgnXov-c6RB6gApp21I585alDD" style="width: 50px; max-width: 10%; height: 10%" title="Click for the larger version." /></a>
```
Level 2
```
<a href="https://drive.google.com/uc?export=view&id=18aPX4ImEhBTCvXuOa_s_z-T54PvqCMIq"><img src="https://drive.google.com/uc?export=view&id=18aPX4ImEhBTCvXuOa_s_z-T54PvqCMIq" style="width: 50px; max-width: 10%; height: 10%" title="Click for the larger version." /></a>

## Abstract

«Monster Slayer» is a 2D game that we have chosen to design not only for children but also for adults
to play. Our main aim in making this assignment was to make an enjoyable game so that people are
both entertained and relaxed when playing it. The main objective of the game is to get to the end of
each level by killing the monsters and collecting coins. This makes it entertaining for people between
10 and above. The game will consist of 3 levels. Once they reach the end of a level, they will progress
to the next with harder to kill monsters. In the third and final level the player must defeat the final
boss before reaching the end of the game. To be able to complete the interfaces and implement the
application, many online tutorials were watched to ease the challenges faced. At the end of the
day, we have succeeded in implementing a game that meets all our aims and objectives stated in
the introduction section. In the future, we are planning to enhance the interface of the application
to make it more fun and interactive.

<a href="https://drive.google.com/uc?export=view&id=1uAJ1dCwkLS7RCXoBIX-isZjvAw-4Zdk7"><img src="https://drive.google.com/uc?export=view&id=1uAJ1dCwkLS7RCXoBIX-isZjvAw-4Zdk7" style="width: 50px; max-width: 10%; height: 10%" title="Click for the larger version." /></a>

<a href="https://drive.google.com/uc?export=view&id=18Dz31pUYJyUL9Y5cbh1AoPu1olvRTLbn"><img src="https://drive.google.com/uc?export=view&id=18Dz31pUYJyUL9Y5cbh1AoPu1olvRTLbn" style="width: 50px; max-width: 10%; height: 10%" title="Click for the larger version." /></a>

<a href="https://drive.google.com/uc?export=view&id=1QZQnR6T9FaMv54Ns8KOoFzBeJKnIdi6S"><img src="https://drive.google.com/uc?export=view&id=1QZQnR6T9FaMv54Ns8KOoFzBeJKnIdi6S" style="width: 50px; max-width: 10%; height: 10%" title="Click for the larger version." /></a>

<a href="https://drive.google.com/uc?export=view&id=1H0lkXdPMc7LTFezAP1a-YlZHCbNqwWZJ"><img src="https://drive.google.com/uc?export=view&id=1H0lkXdPMc7LTFezAP1a-YlZHCbNqwWZJ" style="width: 50px; max-width: 10%; height: 10%" title="Click for the larger version." /></a>

<a href="https://drive.google.com/uc?export=view&id=1qVGZIJtHrJGbO3L4VwqLbXHHNiiXZI0t"><img src="https://drive.google.com/uc?export=view&id=1qVGZIJtHrJGbO3L4VwqLbXHHNiiXZI0t" style="width: 50px; max-width: 10%; height: 10%" title="Click for the larger version." /></a>

## Table of Contents
- 1. Introduction
- 1.1 Introduction
- 1.2 Problem Statement
- 1.3 Aims & Objectives
- 1.4 Scope
- 1.5 Distribution of Task
- 2. Background Study
- 2.1 Introduction
- 2.2 Potential Tools
- 2.3 Summary of Findings
- 3. Analysis
- 3.1 Proposed System - Brief Description of System
- 3.2 Functional Requirements
- 3.3 Non-Functional Requirements
- 3.4 Use Case Diagrams
- 3.5 Tools Choosen
- 4. Design
- 5. Implementation
- 5.1 System Requirements
- 5.2 Implementation of each component
- 6. Testing
- 6.1 Test Plans & Scenarios
- 6.2 Sample Screenshots
- 7. Conclusion
- 7.1 Achievements
- 7.2 Challenges & Problems Encountered
- 7.3 Future Work
- 8. Appendix - User Manual
- 9. References


## 1. Introduction

```
This section will provide an overview about the game, the problem statement, the aims and
objectives, the scope and the distribution of task.
```
## 1.1 Introduction

```
“Monster Slayer” is a 2D game that we have chosen to design for our assignment for the SIS
1040Y - Software Design Fundamentals and Programming module. This document will give
the reader an overview of the game and how it works. This part provides a clear description
of the problem statement, aims and objectives, the scope as well as the distribution of tasks.
```
## 1.2 Problem Statement

```
Nowdays, not only adults but children also make use of technological devices like PC and
mobile phones. This is one of the reason why there has been an exponential growth in the
gaming industry during the last decade. Monster Slayer is a game designed for both adults and
children to enjoy. The combination of pixel art, combat and several obtainable achievements
makes it both a graphically pleasant and extremely enjoyable game. This is why Monster
Slayer can help adults and children get some entertainment in their free time, thus relieving
them temporarily from the stress of their daily activities.
```
```
1.3 Aims and Objectives
The main aim of the game is to get to the end of each level by killing the monsters and
collecting coins. The final aim of the game is to defeat the final boss at the end of the 3rd level.
```
```
The objectives of the game are:
```
1. To make an entertaining game for people between 10 and above.
2. To make an enjoyable game so people are both entertained and relaxed when playing it.
3. To give people rewards in each level to keep them interested and motivated to continue on.

## 1.4 Scope

```
The game will consist of 3 levels. In the first two levels, the player must advance by killing or
avoiding the monsters on its path and by collecting coins scattered across each level. Once
they reach the end of the level, they will progress to the next with harder to kill monsters. In
the third and final level the player must defeat the final boss before reaching the end of the
game. The game ends once the final boss is killed.
```

## 1.5 Distribution of Task

```
Git is a version control system, like "track changes" for code. It is fast, powerful, and
easy-to-use version control system. Our project is stored in a folder named “UnityGame”
locally on our laptop and we collaborate using an online repository on GitHub named
“UnityGame” also.
```
```
We use SourceTree to make our commits and to stay up-to-date while each of us works on a
different branch to develop different components of the game. Below is a screenshot of our
commits in SourceTree. You can see the different branches created so that we can collaborate
while minimizing conflicts.
```
```

## 2. Background Study.................................................................................

```
This section will provide an overview about the existing applications and the tools used to
develop the application.
```
## 2.1 Introduction

```
There are numerous similar applications that are action paced and awards the player for each
achievements such as “Shovel Knight” from Yacht Club Games, “Blasphemous” from The
Game Kitchen and “Cave Story+” from Studio Pixel. Since these are one of the most popular
2D action paced games, our game design will be based off those. Below are some screenshots
from “Blasphemous”, “Cave Story+” and “Shovel Knight”.
```
```
Blasphemous
This is a hack and slash 2D pixel art game developed by the studio “The Game Kitchen”. The
protagonist of the game kills the monsters by slashing them with his sword and can also dodge
and parry attacks. At the end of certain levels there are bosses that spawns and which must be
defeated by the player in order to advance throught the next level. This game was release on
september 10, 2019 and has to this date a 9/10 rating on Steam, a famous game selling
platform, and it has over 3000 positive reviews from players.
```

**Cave Story+**
Arguably the most well-known indie game of all time, Cave Story features a completely
original storyline wrapped with personality, mystery and hours of fast-paced fun. Cave Story
is an action-adventure game from the critically acclaimed independent designer, Daisuke
Amaya. The player controls the on-screen character directly using the keyboard or gamepad.
The player progresses by navigating platform game puzzles and shooting enemies with the
equipped weapon. When the player collects multiple weapons, they may be toggled at any
time with the press of a button.

**Shovel Knight**
Shovel Knight is a 2D side-scrolling platform game developed and published by Yacht Club
Games. The protagonist collects treasure and fights against the Order of No Quarter. Shovel
Knight's primary means of attack is his shovel, which he can either use to attack enemies
head-on and dig up treasure, or aim below him while jumping to bounce on enemies. The
player can purchase secondary items known as relics that can be used with a limited supply of
magic. These include long-range projectiles, gloves that can punch through dirt blocks, and a
locket that makes the player invincible for a brief period.


## 2.2 Potential Tools....................................................................................

```
```
```
Code Editor:
MonoDevelop and Visual Studio are cross platforms that support multiple languages such as
C#. However, Visual Studio is more stable than MonoDevelop. Notepad++ is known for
being the best HTML editor but it does not support large files. Blue Fish is an ultra-fast code
editor that supports various markup languages but it has a lack of extended features for new
programming languages.
```
```
Game Engine:
Unity and Unreal Engine are editors that support 2D as well as 3D platforms. Unity has a lot
of features and assets. This engine is very popular as it is user-friendly compared to Unreal
Engine.
```
```
Game Maker is easy to learn for a beginner since it uses less coding. However, it is not free.
```
```
2D Animation Software & Modelling:
GIMP and Paint are software that can be used to edit images. However, GIMP provides more
sophisticated features that can improve our work.
```
```
StarUML is an open source software modelling tool that supports fast modelling and provides
many powerful features.
```
```
Source Control Manager:
Mercurial is a source control manager which is speedy, both in learning curve and execution
speed. But is has been reported that it is sometimes inconsistent and unpredictable. It is not
suited for each and every job especially large jobs such as game development. Its inflexibility
is its main flaw.
```
```
Git is another source control manager which is widely popular. Although it has a steeper
learning curve than mercurial, it has a huge support base across the internet which we can
consult anytime to look for information. Git is supported accross multiple platforms
especially windows 10 which is the OS we will use throughout this project. Github which
provides hosting is also compatible with git. This can be used to coordinate the work among
the different collaborators of the project.
```
**Type of Tools Tools**
Code Editor MonoDevelop, Visual Studio, Notepad++, BlueFish
Game Engine Unity, Unreal Engine, Game Maker
Source Control Manager Mercurial, Git
Source Control GUI GitKraken, SourceTree
2D Animation Software & Modelling GIMP, Paint, StarUML

```
Source Control GUI:
GitKraken is a modern source control gui. It has a beautiful interface and is simple and
intuitive to use. The most used features (such as pull, push, branch, stash, commit) are
accessible in one click. It is supported on Linux, Mac, and Windows. However, it can have
some issues when opening large repositories and there have been cases where GitKraken
started lagging once they were opened.
```
```
SourceTree is another beautiful, modern and clean source control gui. In addition to
color-coded branches and icons that tell if a file has been added, removed or modified,
SourceTree also displays the number of commits that are ahead and behind the remote branch.
Sourcetree integrates very well with repositories hosted on GitHub. However some
operations can be slow especially on the windows version of SourceTree.
```
## 2.3 Summary of Findings

```
After a thorough research, it can be concluded that the above tools can be used to design and
implement the game and make the latter an interesting one for children while developing their
hidden skills.
```
```
We have decided to make use of Unity game engine since it is a perfect beginner tool to
develop a game and it comprises of all essential elements for developing our game. After
comparing visual studio with MonoDevelop code editor, we have concluded that Visual
Studio is indeed the most suitable code editor for us since it is a vastly superior and more
stable product and it also has a large array of built-in tools.
```
```
We have also decided to use Git as our source control manager as it is much more stable and
practical to use when combined with GitHub. It has all the necessary tools we will need to
both keep different versions of our files and also to collaborate with our teamates.
```
```
And we have chosen SourceTree as our source control GUI as its simple and intuitive UI
makes it easy to use. On top of that its integration with both Git and GitHub will allow us to
have a clean GUI for source control and to collaborate at the same time.
```

## 3. Analysis...................................................................................................

```
This section will provide the analysis of the application, namely the proposed system, the
functional requirements, the non functional requirements, the use case diagrams as well as the
tools chosen for the development of the application.
```
```
3.1 Proposed System – Brief Description of System
The game feature our player which is a knight in our case which can move from left to right and
jump. Along the way, there will be obstacles such as monsters and traps which the player must
kill and avoid respectively. Each level has its own level of difficulty. As we progress through the
game, the game becomes harder because the monsters become harder to kill.
The intermediate objective of the player is to complete all 3 levels and the main objective is to
kill the boss which will appear in level 3.
```
## 3.2 Functional Requirements

- The game shall have a main menu.
- The system shall allow the user to start the game when clicking on the Play button.
- The system shall have a quit button to exit the game.
- After the player has cleared Level 1, the game shall resume at the next level.
- The system shall allow the player to move left and right and jump.
- The system shall allow user to pause the game by pressing the escape button.
- The game must be developed in 2-Dimension.
- Music shall be played when the game has started.

## 3.3 Non-Functional Requirements

- The system shall not crash when launching it.
- The system shall have a user interface.
- The system shall not allow user to move to level 2 unless the first level is cleared.
- The user shall be able to access the game anytime.
- The game shall be played by a single user.
- The game must be developed using Unity3D.
- The game must be implemented using C# scripts.
- The game must run on Windows OS.

## 3.5 Tools Choosen

- Visual Studio is used as the code editor since it is user-friendly and more stable than the other
tools listed above.
- Unity is used as the game engine since it is easy to learn as there are several tutorials. It also
includes assets and cloud storage.
- Git is used as it is fast, powerful, and easy-to-use version control system.
- SourceTree is used as it is has a clean user interface plus it integrates very well with
repositories hosted on GitHub.
- GIMP is used since it has a lot more features than Paint.
- StarUML is used for analysis for its fast modeling feature.


## 5. Implementation

```
This section will provide the system requirements as well as the implementation of the
modules.
```
## 5.1 System Requirements..........................................................................

```
The application requires a Personal Computer (PC) with a keyboard as hardware to play the
game since it requires the arrow keys to control the player. The PC needs 512 MB RAM to
run the application. The storage of the PC must be approximately 200 MB of Hard drive
space. The PC shall have windows as its platform.
```
## 5.2 Implementation of each component

```
Main Menu
The main menu contains two buttons, the “START GAME” button and the “EXIT” button.
The “START GAME” button begins the game and the “EXIT” button exits the application.
The Main Menu is only available at the beginning, before playing the game and when the
player chooses to escape and go to the Main Menu when in the game.
```
```
Start Game Button
The “START GAME” button makes use of the Scene Manager function of unity
(UnityEngine.SceneManagement). This changes the active scene to the next one in the order
that the scenes were placed.
```
```
Exit Button
The “EXIT” button makes use of another Unity function (Application.Quit). This closes the
application therefore closing the game.
```
```
Pause Menu
The pause menu is only accessible while playing the game and is accessed by pressing the
Escape key on the keyboard of the computer. The Pause Menu contains the “RESUME”,
“RESTART”, and “MENU” buttons. The player can press the Escape key again and this will
resume the game, or the player can press the “RESUME” button, and this will continue the
game. The “RESTART” button will reset the current level to the beginning of said level. The
“MENU” button will return the player to the Main Menu where the player can choose to begin
the game again or exit the application. The Pause Menu is not a scene but a prefab that is
accessed through a function.
```
```
Escape Key
The player accesses the Pause Menu by pressing the escape key. The function implemented
checks if the game is paused, and if the escape key is pressed again, it will resume the game
at the exact point it was paused.
```
```
Resume
The “RESUME” button makes use of a bool to check if the game is paused. If the game is
paused and the “RESUME” button is pressed, the game will continue at the exact point where
it was paused. This button also uses the Scene Manager to check if current scene (Pause
Menu) is false and if the game is paused, it resumes the game.
```
```
Restart
The restart button uses the Scene Manager to load the current scene from the beginning. This
also resets hearts and coins to default values at the start of the level.
```

**Menu**
The “MENU” button uses the Scene Manager to return the game to the Main Menu. This is
the first scene loaded when the game is opened and is listed as scene number 0.

**Knight (Player)**
The Knight is the player character and is controlled by using the keyboard and mouse. The
Knight interacts with the game world, moving and jumping around in the level scenes. The
Knight also interacts with objects and enemies to breaks objects like barrels and pots and to
attack enemies that are placed throughout the levels.

The Knight uses several scripts to interact with the game world. These scripts are the **Knight_Combat
(Brackeys, 2019)** script, **Knight_Movement (Unity, 2017)** script, **Knight_Parallax (Dani, 2019)**
script, **Knight_PhysicsObject (Unity, 2017)** script and **Knight_SoundManager (Alexander
Zotov, 2017)** script. All these scripts are used to allow the player to interact with the game world.

**I.** The **Knight_Combat (Brackeys, 2019)** script controls the players combat system. This
allows the player to attack enemies and to also be attacked and take damage. The player
swings his sword which deals damage to the enemies. This control is accessed by pressing the
left button of the mouse and this also plays an attack sound when clicked. There is also an
animation that is played (the sword swinging down) when the left mouse button is clicked.
The Unity function PlaySound is used to play the attack sound and is referenced from the
**Knight_SoundManager (Alexander Zotov, 2017)** script. The animation is played when a
bool is checked if the left mouse button has been clicked and displays the knight animation.

**II.** The **Knight_Movement (Unity, 2017)** script controls the player movement and allows the
player to move when the A, D, Spacebar, Left arrow or Right arrow key is pressed. The A and
Left arrow keys make the player move to the left, the D and Right arrow keys make the player
move to the right and the Spacebar makes the player jump. The left mouse button makes the
player attack as mentioned above in the **Knight_Combat (Brackeys, 2019)** script. The
**Knight_Movement (Unity, 2017)** script uses the Unity function Cinemachine which centers
the main camera to the player, so the player is always in the center of the screen throughout
all movement.

**III.** The **Knight_Parallax (Dani, 2019)** script creates the effect of depth in 2D games. This
makes the background layers move at different speeds relative to the player which makes you
feel the effect of depth. This script is attached to the background images but moves relative to
the Knight.

**I V.** The **Knight_PhysicsObject (Unity, 2017)** script controls the players physics movement
system. This means it controls the players interaction as a physics object with other objects in
the game so the speed at which the player moves as well as the speed the player jumps and the
effect of gravity on the player that makes him return to the ground. It controls the velocity of
the jump and gravity effects. This also makes sure the Knight cannot pass through other
objects. The Knight will interact and be stopped by other objects for example jumping onto a
platform or being stopped by a wall.

**V.** The **Knight_SoundManager (Alexander Zotov, 2017)** script is used to play the sound for
various actions the Knight can do. The Sound Manager loads the audio clip to each relevant
place where it is needed and placed in the script and the game.


**Knight_Barrel**
This script controls how the barrel object reacts when the Knight hits it with the sword. This
causes the barrel to break, which plays an animation of the barrel breaking and plays a sound
referenced from the Sound Manager script

**Knight_Pot**
This script controls how the pot reacts when the Knight interacts with it and works the same
way as the **Knight_Barrel** script.

**Knight_Camera Shake (gamesplusjames, 2019)**
This controls the screen shake effect which is applied to the main camera but centered and
used on the player. When the player breaks a barrel, chest or pot or when then player inflict
damage to enemies, this camera shake effect is applied. The script references the
Cinemachine camera tools.

**Knight_Tips**
The Knight_Tips script controls the tips that are displayed in the game. This controls where
the scripts will be shown and for how long they will be shown in the game world. Uses
OnTriggerEnter2D meaning that the tips are activated when a trigger is accessed.

using UnityEngine;

// This script enables or disables the player tips in Level_Level

// This script is attached to Knight_TipsBox_Move, Knight_TipsBoxSpaceBar, Knight_TipsBoxLeftMouse

public class Knight_Tips : MonoBehaviour
{
public SpriteRenderer render;

void Start()
{
render = GetComponent<SpriteRenderer>(); // Get access to the sprite renderer
}

// If player enters the trigger zone, the sprite renderer is enabled

private void OnTriggerEnter2D(Collider2D other)
{
if (other.CompareTag("Player"))
{
this.render.enabled = true;

}
}

// If player exits the trigger zone, the sprite renderer is disabled

private void OnTriggerExit2D(Collider2D other)
{
if (other.CompareTag("Player"))
{
this.render.enabled = false;
}
}
}


**Power scripts**
These scripts control what the coins, hearts, chests and score counter does. The coin script
increments the counter when a coin is collected by the Knight. The heart script controls the
Knight’s health system, gains hearts when collected in game and if hearts are empty, the
Knight will die. The chest script releases coins and hearts when interacted with and
increments the Knight’s coins and hearts counter. The score text script integrates the Knight
collecting the coins and hearts and displaying this on the screen user interface.

**Power_AddHealth**
This script increments or decrements the hearts. When a heart is collected, the health will be
increased by one unless the health is full. The maximum health amount is four hearts. When
the Knight takes damage, he loses one heart unless all are empty where he will die. This script
also plays an animation and sound when a heart is collected. And is referenced from the
Sound Manger

**Power_Chest**
This script controls what the chest does when interacted with by the Knight. The chest will
open and release coins and hearts at a certain velocity and once opened will remain opened.
Uses a 2D collider so that the Knight can interact with the chest and be able to open it. The
script plays an animation and sound when a chest is opened and is referenced from the Sound
Manager.

**Power_Coin**
Increments the coin amount when collected by the Knight and plays an animation and sound
which is referenced from the Sound Manager.

using UnityEngine;

// This script controls how the coin object reacts when the player collides with it

// This script is attached to Power_Coin

public class Power_Coin : MonoBehaviour
{
public GameObject coinParticle;

void OnTriggerEnter2D(Collider2D col)
{
if (col.gameObject.tag == "Player")
{
// Activates the particle system
Instantiate(coinParticle, col.transform.position, Quaternion.identity);
Knight_SoundManager.PlaySound("Power_Coin"); // Plays the sound effect
Power_ScoreTextScript.coinAmount += 1; // Increments the counter by 1
Destroy(gameObject);
}
}
}

**Power_ScoreTextScript (Alexander Zotov, 2017)**
This script displays and alters the text in real time in the game as the player collects coins. It
increments the coin counter by one for each coin collected.


**Level Scripts**
These scripts control the levels, loading each scene and transitions, this enables the player to
switch or skip scenes at certain times in the game.

**Level_LevelLoader (Brackeys, 2020)**
This script enables us to add a transition between scenes and this script is attached to the level
fade in. Makes use of the Scene Manager Unity Engine.

**Level_LoadingScreen (Jason Weimann, 2017)**
This script allows us to create and add a loading screen between scenes. It is attached to level
switch and delays the start of the next scene by 2 seconds allowing for loading time.

**Level_SceneSwitch**
This script allows the scene to be changed when the Knight gets to the end of the level. The
next level is loaded, and this script makes use of the Unity Engine Scene Manager.

**Level_SkipIntro**
This script enables the player to skip the game introduction and loads the following scene.
Uses Unity Engine Scene Manager.

using UnityEngine;
using UnityEngine.SceneManagement;

// This script enables the user to switch scene by pressing on the skip button

// This script is attached to Level_SkipButton

public class Level_SkipIntro : MonoBehaviour
{
public void skipIntro(string scenename)
{
SceneManager.LoadScene(scenename);
}
}

**Level_Spike**
This controls the spikes in the game that deals damage to the Knight. The Spikes are laid out
throughout the levels and act as collider, so the Knight takes damage when interacting with
them.

**Level_VideoPlayer**
This script preloads the video which plays in the intro scene when the game starts.


**Boss Scripts**
Contains the scripts relating to the boss of level 3. This includes the Boss Health Bar script,
Dragon Fireball Behavior Script, Dragon Pathfinding script, Dragon Projectile Fireball script
and the Dragon Patrol Script. These scripts control the Boss and how it interacts with the
player and the abilities it has during the scene.

**Boss_Health**
Controls the health of the boss, when the boss is dealt damage, the boss loses health.

**Dragon_Fireball_Behavior**
This enables the boss to shoot fireballs at the Knight. The script destroys every second fireball
and reduplicates the first fireball on each update creating the effect of a repeating attack.

**Dragon_Pathfinding**
This script causes the boss to move in a path using AI and the Pathfinding Unity Engine. The
boss moves in an area predetermined by the developer and uses AI computing to determine
the path to follow.

**Dragon_ProjectileFireball**
This script controls the fireballs shot from the boss. It determines the speed and frequency of
the fireballs.

using UnityEngine;
// This script controls the fireballs
// This script is attached to Boss_RedDragron
public class Dragon_ProjectileFireBall : MonoBehaviour
{
public GameObject projectile;
public Transform shotPoint;
private float timeBtwShots;
public float startTimeBtwShots;
private void Update()
{
// This if statement controls how fast the dragon can shoot the fireballs
if (timeBtwShots <= 0)
{
Instantiate(projectile, shotPoint.position, transform.rotation); // (GameObject, Vector3
postion, Quaternion Rotation)
timeBtwShots = startTimeBtwShots;
}
else
{
timeBtwShots -= Time.deltaTime;
}
}
}

**Boss_Attack**
This script makes the dragon deal damage to the player when the latter collides with it. It
controls the amount of damage to deal to the player and the frequency at which to deal
damage.


**Monster Scripts**
Contains the scripts that allow the monster to move, attack, deal damage, drop loot and attack
the player. Allows the monsters to be interactable and collide with the Knight but the Knight
can pass through the monsters

**Monster_Walking (TRGameDev, 2017)**
This script is used to make the common monsters walk in a limited area. It detects a limit and
flips the monster around, making them move towards the opposite direction.

using UnityEngine;

// This script will control the patrolling enemies

// It is attached to the common enemies

/*
TRGameDev, 2017 : Quick and Simple Unity Patrol AI in Less Than 10 Minutes C#
Available from: https://www.youtube.com/watch?v=we44Z3yR2Ec
*/

public class Monster_Walking : MonoBehaviour
{
public Rigidbody2D rb;
public SpriteRenderer sr;
public float speed = 2;

void FixedUpdate()
{
rb.velocity = Vector2.right * speed; // This will make the enemy move towards the right
}

// This fucntion will make the enemy move in a limited area
// It detects when two object collides
void OnTriggerEnter2D(Collider2D col)
{
if (col.gameObject.tag == "Limit") // If the enemy collides with the object limit
{
if (sr.flipX == false) // This will flip the monster making it turn around
{
sr.flipX = true;
speed = -2; // Moving the monster in the way it is facing
}
else
{
sr.flipX = false;
speed = 2;
}
}
}
}


**Monster_Attack (Brackeys, 2019)**
This script controls the common monsters. It attacks the player by creating a circle at a
position within a certain range and detects a layer boundary where it moves toward the Knight
to attack him (the player). The monster deals damage to the Knight and receives damage from
the Knight and will die when hit a certain number of times. The common monsters will only
patrol and deal damage when collided with by the Knight, but the Monster_Bandit can attack
the Player and is harder to defeat. This script also plays a sound and animation when monsters
attack and die.

**Monster_EnemyState (Brackeys, 2019)**
This script contains the health of the player and monsters and will make the monster die when
hit by the Knight a certain number of times. This script defines the health amount of the
monsters and the amount of hits needed to defeat it.

**Monster_Enemies**
This script controls the monsters and makes them move towards the Knight. It will detect the
Knight within a certain range and when the monster gets near, it will start attacking the Knight
instead of just moving around like the common enemies. It contains the enemy’s health and
will trigger appropriate animations.

**Monster_Flying**
This script controls the flying monsters. When the Knight gets into a certain range the monster
will move towards the Knight and start attacking the Knight. It is similar to the enemy
walking script as it just defines an area where the Knight will trigger and be attacked.

**Monster_Loot**
This script makes objects spawn with a defined amount of force. It is used in the
Monster_EnemyState script and Monster_Flying script to make coins and hearts spawn when
the monsters die.


## 6.2 Sample Screenshots

```
This figure shows the Main Menu Screen where the player has the option to either start the
game or exit the game. The main menu also features a dynamic background with matching
background music.
```
## Figure 17 : Main Menu Scene

```
This figure shows what happens when the player clicks on “START GAME”; this will then
bring the latter to the loading screen
```
## Figure 18 : Loading Screen


This figure shows the first level’s introduction video of “Monster Slayer”. This will appear as
soon as the loading screen is over. This will show a short and concise video depicting the story
of the game. It will have a skip button as well on the top left which will allow the player to
skip the video in case he shows no interest in watching it.

## Figure 19 : Introduction Video


This figure shows the gameplay of the first level of “Monster Slayer” which is loaded after
the introduction video. It shows mini tutorial guidelines at various triggers found all across
the map. On the top left of the screen, we can see the health of the player in terms of number
of hearts. We can also see a coin counter which shows how many coins have been
accumulated by the player across the level.

## Figure 20 : Level

This figure shows the second level of “Monster Slayer”. It has the same format as the first
one; health and coin display on the top left of the screen. In the screenshot, we can also see
a chest which is optional. To open the chest, the player has to simply hit it. The contents of
the chest can either be coins, a health point (heart) or even both.

## Figure 21 : Level


This figure shows the third and final level of “Monster Slayer”. In this level, the player has to
fight the final monster of the wizard which is a ferocious dragon unleashing fireballs to the
ground. The player has to jump on platforms in order to be able to hit and damage the dragon.
The fireballs which is spit by the dragon is what deals damage to the player.

```
Figure 22: Level 3
```
This figure shows the End Credits Scene. In this, we thank the player for allocating time to
play our game, “Monster Slayer”. This is followed by our game’s name, our student IDs,
the references we used like music, assets amongst others.

## Figure 23 : End Credits


This figure shows the pause menu. This is shown to the player when he presses the ‘Esc’
button. He will be given the option to resume, restart or go to the main menu. Pressing
‘RESUME’ will take him back to the level; ‘RESTART’ will reset the scene and pressing
‘MENU’ will take the player back to the main menu as shown in Figure 1.

## Figure 24 : Pause Menu

This figure shows the game over screen. This is when the player’s character dies, that is his
health is completely depleted. In the level, the player will fall to the ground and this scene will
be triggered. In this scene, the amount of coins collected will be shown on the top left of the
screen. It will also give the player the option of either ‘RESTART’ or ‘MENU’. ‘RESTART’
will simply reset the level as well as the coin counter. ‘MENU’, on the other hand, will bring
the player back to the main menu. From there, the player can either decide to restart the game
all over again or exit the application.

## Figure 25 : Game Over


## 7. Conclusion..............................................................................................

## 7.1 Achievements......................................................................................

```
Throughout this assignment, we have been able to develop both technical and non technical
skills.
```
```
The technical skills are:
```
- Writing C sharp scripts.
- Learning how to use unity.
- Learning how to design interfaces using unity.
- Learning how to use git, github & SourceTree.
- Editing photos by removing their backgrounds using GIMP.

```
The non-technical skills are:
```
- Developing team spirit.
- Self-learning.
- Managing time.
- Coping with workload process.

```
7.2 Challenges and problems encountered
Since we are beginners and Monster Slayer was our first game application to be developed,
indubitably we encountered some challenges while implementing it. To be able to complete
the interfaces and implement the application, many online tutorials were watched to ease the
challenges faced.
```
## 7.3 Future Work........................................................................................

```
Since the targeted audience for this game is mostly children above 10 years old, we are
planning to enhance the interface of the Monster Slayer application to make it more fun,
interactive as well as more innovative.
```
```
Moreover, more levels can be included to make the game more interesting as well as increase
the level of difficulty for teenagers who want to play the game.
```

## 8. Appendix - User Manual.......................................................................

**For player movement:**

- D/Right Arrow key - Move to the right
- A/Left Arrow key - Move to the left
- Space Bar - Jump
- Left Mouse Click - Attack

```
For Pause Menu:
```
- Escape Key - Pause Menu
- Resume Button - Resume Game
- Restart Button - Restart Game
- Menu Button - Return to the Main Menu

```
In Start menu:
```
- Start Button - Start the game
- Exit Button - Exit the game

```
In Intro Scene:
```
- Skip Button - Skips the intro video

```
Objective of the player:
In level one, the knight should try to survive by killing or if possible avoid the monsters,
collect coins and proceed to the next level. In level two, its going to be the same but there will
be more monsters and hence it is going to be more difficult. In the final level, that is level 3,
the player should kill the main boss(the dragon) to end the game.
```

## 9. References

```
Alexander Zotov, 2017. How to create a simple coin counter in your Unity game? Easy Unity 2D
tutorial [video online]. Avaliable at : https://www.youtube.com/watch?v=-EIXQHxoicg [Accessed 24
February 2020]
```
```
Alexander Zotov, 2017. How to add sound or audio effects SFX to Unity 2D arcade game | Very simple
Unity 2D Tutorial [video online].
Available at: https://www.youtube.com/watch?v=8pFlnyfRfRc [Accessed 18 February 2020]
```
```
Brackeys, 2017. PAUSE MENU in Unity [video online].
Available at: https://www.youtube.com/watch?v=JivuXdrIHK0 [Accessed 05 March 2020]
```
```
Brackeys, 2019. MELEE COMBAT in Unity [video online]. Available at:
https://www.youtube.com/watch?v=sPiVz1k-fEs&list=LLH3a8ESny180HvT46FvAlAw&index=15
[Accessed 3 February 2020]
```
```
Brackeys, 2020. How to make a HEALTH BAR in Unity! [video online]
Available at : https://www.youtube.com/watch?v=BLfNP4Sc_iA [Accessed 02 March 2020]
```
```
Brackeys, 2020. How to make AWESOME Scene Transitions in Unity! [video online]
Available at: https://www.youtube.com/watch?v=CE9VOZivb3I&t=724s [Accessed 16 February 2020]
```
```
Dani, 2019. Unity Parallax Tutorial - How to infinite scrolling background [video online].
Available at: https://www.youtube.com/watch?v=zit45k6CUMk [Accessed 10 February 2020]
```
```
Gamesplusjames, 2019. Adding ScreenShake In Unity [video online]. Available at:
https://www.youtube.com/watch?v=8PXPyyVu_6I&list=LLH3a8ESny180HvT46FvAlAw&index=9
[Accessed 21 February 2020]
```
```
Jason Weimann, 2017. How to load a scene after a timer or delay in Unity3D with SceneManager
[video online]. Available at:
https://www.youtube.com/watch?v=Oe9BZVnoedE&list=LLH3a8ESny180HvT46FvAlAw&index=6
[Accessed 15 February 2020]
```
```
TRGameDev, 2017. Quick and Simple Unity Patrol AI in Less Than 10 Minutes C# [video online].
Available at: https://www.youtube.com/watch?v=we44Z3yR2Ec [Accessed 05 March 2020]
```
```
Unity, 2017. 2D Platformer Character Controller [video online]. Available at:
https://www.youtube.com/watch?v=wGI2e3Dzk_w&list=PLX2vGYjWbI0SUWwVPCERK88Qw8hpjEGd8
[Accessed 11 February 2020]
```

